# Testbench Design

该文档用来说明Cache开发中的testbench的主要构造以及相关信息。

写在开头：设计好一个优秀的Testbench是非常难的，但是其重要性在大规模项目中显得格外重要，虽然龙芯具有完整CPU的testbench，但是本着独立开发，不给团队添乱的宗旨，以及即使是接入完整CPU以进行调试会极大增大调试复杂度，我们需要事先进行相关的测试，在大程度上保证整个Cache不能够出错，其中我们应该要进行基本功能和冲突例外鲁棒验证。对应的测试文件在sim文件夹中，由于时间和作者本人水平限制，最终采用的是最简单的激励方式设计Testbench，若有更好的方式欢迎补充。

### 作者

李程浩，哈尔滨工业大学（深圳），2020届龙芯杯UltraMIPS团队队长。

loancold@qq.com

### CacheAXI_Interface

#### 基本功能

ICache从主存中读取块，验证是否成功将返回的字包装成块，并且完成时返回相应的完成信号。

设置读使能和地址，接下来八次，每次等待。

发现问题：

- 时序问题，给Cache的数据传输成功信号采用组合逻辑，使得还没有真正成功的时候就输出了成功信号，现在应该将其改为时序逻辑。
- 时序问题，在某个字进行读取的时候，还没有等到返回正确数据就写入了总线的数据，这将导致打包块的最后一个数据的时候错误的将第一个字置为最后一个字。

DCache从主存中读取块，验证是否成功将返回的字包装成块，并且完成时返回相应的完成信号。

DCache从主存中写入块，验证是否成功将写入的块拆成字，并且完成时返回相应的完成信号。

#### 鲁棒验证

当ICache和DCache同时读时，判定是否让DCache先读，同时在这个过程中是否信号正常。

在ICache读时若遇见DCache读，是否能够让ICache返回，并且DCache信号正常。

读写同时进行。



### WriteBuffer

#### 基本功能

基本写入：写入一个块，模拟总线的交互，看FIFO状态是否跳转成工作状态，并且送出的数据是否对应。之后设置写入完成信号，观察是否成功跳转为空状态，队头队尾指针是否正确。

FIFO状态：连续写入8个地址不同的块，看FIFO能否成功跳转至满状态。在队列中国有多个块的时候能否成功进行主存写操作。

读访问：在上一个测试中途加入三个块的读操作，一个命中一个不命中再有一个命中失效单元。

写冲突：写操作命中FIFO中已有的块。

#### 鲁棒验证

特殊读访问：读操作命中现在正在写的块 。

特殊写入：写入FOFO的块与正在写入主存的块地址相同，验证是否进行覆盖并且重写。

特殊读访问：读操作命中已经被覆盖的块 。

极端特殊写入：在正在写入主存的块刚好被写完的时候进行特殊写入，验证是否成功。



### DCache

由于DCache功能特性原因，难以进行仿真的设计，因此我们采用白盒黑盒方式进行设计，以尽量囊括更多的功能测试。

#### 基本功能（黑盒）

读指令不命中：读一个字，是否成功判定不命中并与总线成功交互（第一次地址0，同时测试valid的作用），并且观察暂停信号输出是否正确。

读指令命中：验证不向总线提出请求。

写指令命中：成功判定命中，验证脏位设置是否正确。

写指令不命中：成功判定不命中，验证脏位设置是否正确。

输出暂停信号：在处理对应数据的时候是否成功暂停。具体验证见Cache_Design.md中的暂停部分。

#### 内部处理机制验证（白盒）

WriteBuffer过载：Buffer已满，是否成功暂停等待 。

特殊写入：写入FIFO的块与正在写入主存的块地址相同，验证是否进行覆盖并且重写。

特殊读访问：读操作命中已经被覆盖的块 。

同一个组读指令不命中：同理。

伪LRU替换：再次进行同一个组读指令不命中，看替换法则是否成功运行。

### 更多（作者有话说）

实际上在这之后，Cache的开发仍然遇到了非常多的bug。作为一个从头至尾一直在出bug，调bug的开发者（我），非常建议早期就解决一些肤浅的错误，虽然需要在制作testbench上花费一些时间，但是这一切都是值得的，保证基本的接线、逻辑错误是否能够得到修正。

但是对于复杂的验证，我们需要将其置于更复杂的测试环境下才能够进行检测。在龙芯杯中，采用function test使用trace即可做到，因此我们只要编写比较基础的testbench即可。但是如果时间比较充足的话，还是建议使用更为高级的方法。作者的建议：做一个Cache专用test模板，测试不同的读写数据以及时序，测试最后是否正确。这样需要考虑axi方面和cpu方面的行为模拟，这需要一点时间，但是这很值得。

