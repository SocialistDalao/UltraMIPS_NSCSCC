# 分支预测设计文档

#### 作者

宫浩辰，哈尔滨工业大学（深圳），主要负责外设、分支预测、AXI开发。

#### 概述

分支预测要预测是否跳转和目的地址。

采用动态分支预测。

一共设计了两款分支预测器，下文使用旧款、新款描述。旧款分支预测器结构复杂，采用竞争分支预测，具备BTB和RAS，能力相对平均，整体正确率85%。新款的结构和逻辑都很简单，不具备局部历史或全局历史预测，只保留一个缓存存放两位计数器、跳转地址、跳转类型，整体命中率91%，但在部分程序中命中率极低。

具体原理见：《超标量处理器设计》（姚永斌）

#### 方向预测

即预测跳转 / 不跳转。

硬件：

分支历史寄存器表 BHT（即局部历史）

全局历史寄存器 GHR

模式历史表 PHT0(全局)    PHT1(局部)    由两位饱和计数器表构成，四种状态，描述跳转的可能性

选择模式历史表 CPHT    由两位饱和计数器表构成，四种状态，描述倾向于哪一种预测方法。

采用竞争的方式进行预测。

同时使用基于局部历史和基于全局历史的方式预测，根据历史的预测情况二选一。

除了寄存器写入采用时序逻辑，其余均采用组合逻辑。



注：新版分支预测中，只保留了两位饱和计数器，因此对于ABABAB等分支类型无法预测。

但是这种情况很少，因此整体效果较好。



#### 目的地址预测

即预测跳转的地址。原理是存储分支指令的历史跳转地址，根据历史预测。

跳转指令可分为直接跳转、间接跳转

间接跳转又分为一般的间接跳转、CALL、RETURN

考虑到JR通常和JAL等配合使用 统一归为RETURN  因此无一般间接跳转的预测



使用两个存储器存放历史跳转地址，分别是：

1.分支目标缓存 BTB   存储所有跳转目标和分支类型（例如直接、call、return）

2.返回地址堆栈 RAS   存储返回类型的跳转目标（JAL和JR配合使用的情况）

二者均在ex阶段获得正确分支信息后修正。预测时，btb命中后根据分支类型决定使用哪个存储器的预测结果。



在旧版分支预测中，不论之前提及的方向预测，还是目的地址预测，均不使用PC直接作为表的索引，而是将GHR、BHR与PC部分异或，然后通过再异或压缩得到索引。这样的好处是可以在不同情况下对同一条分支指令预测，缺点是结构过于复杂，而且可能导致检索到的分支信息和PC不匹配（不同PC压缩后得到同一个索引）。具体方法见代码，不再赘述。此外，由于动态取指架构的引入，分支指令从预测阶段到执行阶段的周期数并不固定，而旧版分支预测更新信息从EX获取。因此，需要将预测信息和计算得到的索引打包，顺流水而下，在EX阶段回传，然后根据包中的索引和正确预测信息对各个表进行修复。需要注意的是，不建议将EX阶段的PC回传然后再次hash一次，一方面组合逻辑时延大，另一方面因为GHR会变，所以全局历史预测时得到的索引和之前可能不是一个。



#### 已优化

##### 去除冗余

​		观察程序可以发现大多的分支以循环的结构出现，因此只需要一个BTB存放地址，一个两位饱和计数器表预测是否跳，就可以十分快速地收敛，每次循环除了第一次和最后一次错，剩余全部正确。

​		除此之外，在旧版分支预测器中，对PC的哈希处理和压缩极有可能导致不同PC对应相同的索引，导致预测不准确。因此新版分支预测器中使用直接映射的方法作为BTB的索引，即将PC拆分为index和tag。这样可以保证BTB一旦命中，则当前指令必为分支指令，且检索到的分支信息必为该指令的历史分支信息，一次避免指令和分支信息不对应的错误。

​		这样做的另一个好处是，可以精确地修复和更新分支信息。由于动态取指架构的引入，分支指令从预测阶段到执行阶段的周期数并不固定。这对于老的预测器来说是噩梦，在预测完后需要把所有索引发出，最后伴随实际的分支信息回传。这是因为EX获得正确分支信息后，GHR和BHR可能都已经发生改变，所以如果EX把PC回传，那么PC经过hash后得到的索引很可能不是原来的。而采用直接映射的索引后，只要从EX回传PC和对应的分支信息，就可以精准修正，因为PC就是索引。

##### 针对性预测

​		对于一些类型的分支指令，例如 J 、JR 、JAL等，一定会跳转，因此可以直接将饱和计数器设为strongly taken。



#### 可优化处（一些大胆的想法）

##### 进一步针对预测

​		在旧版和新版分支预测中，均尝试过加入RAS，但效果不佳。分析原因，发现JAL和JR指令不一定配对使用，也就是说，JR指令的跳转地址也不一定存放于31号寄存器。之后尝试了对使用31号寄存器的JR指令精准预测，但提升不大。不过可以确定的是，每条JAL指令跳的地址是固定的，同时，每条JR指令的跳转地址也只会存放于同一个寄存器，因此可以尝试将所有寄存器值直接引入BPU，同时增加一个表存放分支指令使用到寄存器。

​		这样一来就可以预测分支指令用到的寄存器，因此进一步，还可以较精准地预测BEQ、BNE等条件分支指令是否跳转（看代码和仿真波形可以发现，这类分支指令的比重还是比较大的）。如此一来，对于哪些时而跳转，时而不跳转的分支指令，甚至时毫无规律的分支指令，都可以做到几乎精准的预测，不必再纠结局部历史或者全局历史。因为可能存在数据相关，需要引旁路，所以可能需要注意组合逻辑时延问题。

​		在使用上述方法时，可以适当增大BTB，如采用组相联，来增大命中的概率。

##### 更加恰当地引入全局/局部历史预测

​		如果组合逻辑时延较大，还是可以使用全局/历史预测。因为板上资源使用率并不高，可以大胆使用空间。所以对于之前提到的查找表（如BHT、PHT）索引，可以不必将PC进行hash处理和压缩，而是可以直接拼合。例如将PC拆分为index和tag，然后将index和GHR拼合（{GHR, index}）作为索引 。这样做可以预测比较规则的分支结构，但对于不规则的结构，理论上远不如直接引入寄存器。



#### 性能

**old edition** 

5805     2364     2844

25020   8502   10477

78461   26471  36583

53289    47872    1967

14529    9922    3281

32331    8987    14921      73.95%

51930   42964    6538       95.38%

23582   19558   2425

2256    1840   220 

28865     19835    5271

**total :  86.32%**

**min:  73.95%**

**max:  95.38%**



##### lite edition

只计算跳转的命中

ss    sha  ds  **bs**   cm   crc   **qs**   sc   ssearch   **bc**

43612        44386

20636       20963

10369       11101

9445         13013

32618       40000

49261        50941

12052        15923

1933          2053

21687        23190

1780          2894

​    0.9826
​    0.9844  (max)
​    0.9341
​    **0.7258**
​    0.8155
​    0.9670
​    **0.7569**
​    0.9415
​    0.9352
​    **0.6151**

hit: 203393             all: 224464

整体命中率 90.61%

